Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FTC_14133_2021_Auto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;// https://first-tech-challenge.github.io/SkyStone/  This is the link to ALL metered of FTC\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\nimport com.qualcomm.robotcore.hardware.DigitalChannel;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\n\r\n@Autonomous(name=\"FTC 14133 2021 Auto\", group=\"Auto\")\r\npublic class FTC_14133_2021_Auto extends LinearOpMode {\r\n    private ElapsedTime runtime = new ElapsedTime();\r\n    private DcMotorEx lb = null;        // Sets the variables of the mecanum wheels\r\n    private DcMotorEx rb = null;\r\n    private DcMotorEx lf = null;\r\n    private DcMotorEx rf = null;\r\n    static final double MOTOR_TICK_COUNT = 2800;        //\r\n    private DcMotorEx shooter = null;         // Sets the variable of the shooter\r\n    private DcMotorEx arm = null;         // Sets the variable of the arm that is long but there is not a arm that is short\r\n    private DcMotorEx intake = null;          // Sets the variable of the intake\r\n    private DcMotorEx conveyor = null;          // Sets the variable of the conveyor\r\n    //   DigitalChannel LimitSwitchLongArm;          // Sets the variable of the LimitSwitchLongArm\r\n    DigitalChannel beambreak;          // Sets the variable of the beambreak\r\n    Servo leftclaw = null;          // Sets the variable of the Claw\r\n    Servo rightclaw = null;          // Sets the variable of the Claw\r\n    boolean clawstate = false;          // Sets the variable of the clawstate\r\n    boolean toggle = true;          // Sets the variable of the toggle\r\n    public int count = 0;\r\n\r\n\r\n\r\n    void ForwardorBackwardsCount(double distance, double speed) {\r\n        lf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        lb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        //Driving forward/backwards\r\n        //  double distance= 5; //(in)\r\n        double encodercounts = distance * 60.3686819388;//(1/(75*(1/25.4)))*560;\r\n        int encodercountsint = (int) encodercounts;\r\n        lf.setTargetPosition(encodercountsint);\r\n        lf.setPower(speed);        //Sets the power for the left front wheel\r\n        rf.setTargetPosition(encodercountsint);\r\n        rf.setPower(speed);        //Sets the power for the right front wheel\r\n        lb.setTargetPosition(encodercountsint);\r\n        lb.setPower(speed);        //Sets the power for the left back wheel\r\n        rb.setTargetPosition(encodercountsint);\r\n        rb.setPower(speed);        //Sets the power for the right back wheel\r\n        lb.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        lf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rb.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        //Rotate(1, 0.5);\r\n\r\n        while (lf.isBusy() || rf.isBusy() /*|| lb.isBusy() || rb.isBusy()*/) {\r\n            //run until motors arrive at position\r\n            if(!beambreak.getState()) { //if beam is broken\r\n                conveyor.setPower(1);//Run conveyor\r\n                telemetry.addData(\"count\", count);\r\n                telemetry.addData(\"toggle\", toggle);\r\n                telemetry.addData(\"beambreak\", beambreak.getState());\r\n                telemetry.update();\r\n\r\n                if (toggle){ //if toggle is true, or there was no ring in last loop\r\n                    count = count + 1;\r\n                    toggle=false; //set to false to stop count\r\n                    telemetry.addData(\"count\", count);\r\n                    telemetry.addData(\"toggle\", toggle);\r\n                    telemetry.addData(\"beambreak\", beambreak.getState());\r\n                    telemetry.update();\r\n                }\r\n            }\r\n            else{ // if beam break not broken\r\n                toggle=true; //set to false to allow for count next time ring breaks beam\r\n                conveyor.setPower(0); // stop conveyor\r\n                telemetry.addData(\"count\", count);\r\n                telemetry.addData(\"toggle\", toggle);\r\n                telemetry.addData(\"beambreak\", beambreak.getState());\r\n                telemetry.update();\r\n            }\r\n\r\n        }\r\n        conveyor.setPower(0); //stops conveyor if loop ended with conveyor running\r\n    }\r\n\r\n    void ForwardorBackwards(double distance, double speed) {\r\n        lf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        lb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        //Driving forward/backwards\r\n        //  double distance= 5; //(in)\r\n        double encodercounts = distance * 60.3686819388;//(1/(75*(1/25.4)))*560;\r\n        int encodercountsint = (int) encodercounts;\r\n        lf.setTargetPosition(encodercountsint);\r\n        lf.setPower(speed);        //Sets the power for the left front wheel\r\n        rf.setTargetPosition(encodercountsint);\r\n        rf.setPower(speed);        //Sets the power for the right front wheel\r\n        lb.setTargetPosition(encodercountsint);\r\n        lb.setPower(speed);        //Sets the power for the left back wheel\r\n        rb.setTargetPosition(encodercountsint);\r\n        rb.setPower(speed);        //Sets the power for the right back wheel\r\n        lb.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        lf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rb.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        //Rotate(1, 0.5);\r\n\r\n        while (lf.isBusy() || rf.isBusy() /*|| lb.isBusy() || rb.isBusy()*/) {\r\n\r\n        }\r\n    }\r\n\r\n\r\n    void Rotate(double turn, double speed) {\r\n        lf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        lb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        //Driving left/right\r\n        //NOT DONE\r\n        double encodercounts = turn * 13.18; // test iteratively\r\n        int encodercountsint = (int) encodercounts;\r\n        lf.setTargetPosition(-encodercountsint);\r\n        lf.setPower(speed);        //\r\n        rf.setTargetPosition(encodercountsint);\r\n        rf.setPower(speed);        //Sets the power for the Long arm\r\n        lb.setTargetPosition(-encodercountsint);\r\n        lb.setPower(speed);        //Sets the power for the Long arm\r\n        rb.setTargetPosition(encodercountsint);\r\n        rb.setPower(speed);        //Sets the power for the Long arm\r\n        lb.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        lf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rb.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        while (lf.isBusy() || rf.isBusy() /*|| lb.isBusy() || rb.isBusy()*/) {\r\n            //run until motors arrive at position\r\n        }\r\n    }\r\n\r\n    void Strafing(double Strafe, double speed) {\r\n        lf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        lb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        //Driving left/right\r\n        //Positive is Strafing left negative is Strafing right\r\n        double encodercounts = Strafe * 60.3686819388 * 1.4142135623730950488016887242097;\r\n        int encodercountsint = (int) encodercounts;\r\n        lf.setTargetPosition(-encodercountsint);\r\n        lf.setPower(speed);        //\r\n        rf.setTargetPosition(encodercountsint);\r\n        rf.setPower(speed);        //Sets the power for the Long arm\r\n        lb.setTargetPosition(encodercountsint);\r\n        lb.setPower(speed);        //Sets the power for the Long arm\r\n        rb.setTargetPosition(-encodercountsint);\r\n        rb.setPower(speed);        //Sets the power for the Long arm\r\n        lb.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        lf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rb.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        while (lf.isBusy() || rf.isBusy() /*|| lb.isBusy() || rb.isBusy()*/) {\r\n            //run until motors arrive at position\r\n        }\r\n\r\n\r\n    }\r\n\r\n    boolean IntakeFunction(double speed) {\r\n        intake.setPower(speed);\r\n        if (!beambreak.getState()) {\r\n            conveyor.setPower(speed);\r\n        }\r\n        if (speed == 0) {\r\n            return false;\r\n        } else {\r\n            conveyor.setPower(0);\r\n            return true;\r\n        }\r\n\r\n    }\r\n\r\n    void ConveyorFunction(double speed) {\r\n        conveyor.setPower(speed);\r\n        intake.setPower(speed);\r\n    }\r\n\r\n    void LongArmFunctionDown() {\r\n        double armrotation = MOTOR_TICK_COUNT * (0.4);\r\n        arm.setPower(0.3);        //Sets the power for the Long arm\r\n        arm.setTargetPosition((int) armrotation);        //Tell the motor to go to 90 degrees when told to\r\n        arm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        while (arm.isBusy()){\r\n            //run until motors arrive at position\r\n        }\r\n    }\r\n\r\n    void LongArmFunctionUP() {\r\n        arm.setPower(0.3);        //Sets the power for the Long arm\r\n        arm.setTargetPosition(100);        //Tell the motor to go to 90 degrees when told to\r\n        arm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        while (arm.isBusy()){\r\n            //run until motors arrive at position\r\n        }\r\n    }\r\n\r\n    void ClawClose() {\r\n        leftclaw.setPosition(1);\r\n        rightclaw.setPosition(0);\r\n    }\r\n\r\n    void ClawOpen() {\r\n        leftclaw.setPosition(0);\r\n        rightclaw.setPosition(1);\r\n    }\r\n\r\n    public void waitForStart() {\r\n    }\r\n\r\n    public void runOpMode() {\r\n        lf = (DcMotorEx)hardwareMap.get(DcMotorEx.class, \"lf\");       //sets the names of the motors on the hardware map\r\n        rf = (DcMotorEx)hardwareMap.get(DcMotorEx.class, \"rf\");\r\n        lb = (DcMotorEx)hardwareMap.get(DcMotorEx.class, \"lb\");\r\n        rb = (DcMotorEx)hardwareMap.get(DcMotorEx.class, \"rb\");\r\n        arm = (DcMotorEx)hardwareMap.get(DcMotorEx.class, \"arm\");\r\n        shooter = (DcMotorEx)hardwareMap.get(DcMotorEx.class, \"shooter\");\r\n        intake = (DcMotorEx)hardwareMap.get(DcMotorEx.class, \"intake\");\r\n        conveyor = (DcMotorEx)hardwareMap.get(DcMotorEx.class, \"conveyor\");\r\n        beambreak = hardwareMap.get(DigitalChannel.class, \"beambreak\");\r\n        leftclaw = hardwareMap.get(Servo.class, \"leftclaw\");\r\n        rightclaw = hardwareMap.get(Servo.class, \"rightclaw\");\r\n        telemetry.addData(\"count\", count);\r\n        telemetry.addData(\"toggle\", toggle);\r\n        telemetry.addData(\"beambreak\", beambreak.getState());\r\n        telemetry.update();\r\n\r\n        final double driveP = 2.5;        //PIDF values will change, these are filler values\r\n        final double driveI = 0.1;\r\n        final double driveD = 0.2;\r\n        PIDFCoefficients drivePIDF = new PIDFCoefficients(driveP, driveI, driveD, 0);\r\n        //lf.setPIDFCoefficients(DcMotorEx.RunMode.RUN_USING_ENCODER, drivePIDF);\r\n        //rf.setPIDFCoefficients(DcMotorEx.RunMode.RUN_USING_ENCODER, drivePIDF);\r\n        //lb.setPIDFCoefficients(DcMotorEx.RunMode.RUN_USING_ENCODER, drivePIDF);\r\n        //rb.setPIDFCoefficients(DcMotorEx.RunMode.RUN_USING_ENCODER, drivePIDF);\r\n\r\n        lf.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        rf.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        lb.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        rb.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        shooter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        intake.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        conveyor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        shooter.setDirection(DcMotorEx.Direction.REVERSE);            //sets the directions of the motors\r\n        lf.setDirection(DcMotorEx.Direction.FORWARD);\r\n        rf.setDirection(DcMotorEx.Direction.REVERSE);\r\n        lb.setDirection(DcMotorEx.Direction.FORWARD);\r\n        rb.setDirection(DcMotorEx.Direction.REVERSE);\r\n        beambreak.setMode(DigitalChannel.Mode.INPUT); // set the digital channel to input.\r\n        ClawClose();\r\n        arm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        lf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        //Since this is the first time using the encoder we start it up\r\n        rf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        lb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rb.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        shooter.setVelocity(2500);\r\n\r\n        ForwardorBackwardsCount(57, 0.75); // Drive forward from wall\r\n\r\n        Strafing(-16, -0.5);   // scoot left until aligned with top goal\r\n\r\n        ConveyorFunction(1);  //shoot rings in conveyor\r\n\r\n        sleep(3500); //time to shoot rings in conveyor\r\n\r\n        intake.setPower(1);//begin running intake\r\n\r\n        ForwardorBackwardsCount(-14,0.5); //move quickly to ring stack\r\n\r\n        ForwardorBackwardsCount(-16, 0.5);    // move slowly to pick up rings, count code in drive while loop\r\n\r\n\r\n\r\n\r\n\r\n        ConveyorFunction(0); // stop shooting\r\n        if (count == 0) {       // if zero rings are picked up, do this portion of code\r\n\r\n            ForwardorBackwardsCount(24, 0.75); // move back to line to shoot\r\n\r\n            Strafing(12, -0.75);    // Moving to the left the put wobble goal into first box\r\n\r\n            LongArmFunctionDown();\r\n\r\n            sleep(200);\r\n\r\n            ClawOpen();    // Opening Claw\r\n\r\n            sleep(150);\r\n\r\n            ForwardorBackwardsCount(-50,0.75);   // Going backwards to pick up second wobble goal\r\n\r\n            Rotate(90,0.7);\r\n\r\n            ForwardorBackwardsCount(7.5, 0.65);    //Going farther the pick up second wobble goal\r\n\r\n            ClawClose();    //Closing Claw\r\n\r\n            sleep(200);\r\n\r\n            Rotate(-88,0.75);  //Rotating to bring second wobble goal into first box\r\n\r\n            ForwardorBackwardsCount(43, 1);  //Going really fast to put wobble goal down\r\n\r\n            ClawOpen();    //Opening Claw\r\n\r\n            sleep(150);\r\n\r\n            //LongArmFunctionUP();\r\n\r\n            //   Strafing(10, 1);\r\n\r\n            //  LongArmFunctionDown();\r\n\r\n            ForwardorBackwardsCount(-10, 0.75);\r\n        }\r\n        if (count == 1) {\r\n            //ConveyorFunction(1); //begin shooting\r\n\r\n            //sleep(3500); //time to shoot\r\n\r\n            //ForwardorBackwards(18, 0.75);\r\n\r\n            //Strafing(-6,0.75);\r\n\r\n\r\n\r\n            ForwardorBackwardsCount(44, 0.75);   // Going to put first wobble goal into second box\r\n\r\n            //ConveyorFunction(1); //begin shooting\r\n\r\n           //sleep(3500); //time to shoot\r\n\r\n            //ForwardorBackwards(18, 0.75);\r\n\r\n            Strafing(-6,0.75);\r\n\r\n            LongArmFunctionDown();\r\n\r\n            //sleep(240);\r\n\r\n            ClawOpen();\r\n\r\n            sleep(240);\r\n\r\n            //LongArmFunctionUP();//\r\n\r\n            ForwardorBackwardsCount(-38,0.75);\r\n\r\n            Rotate(183,0.75);\r\n\r\n            ForwardorBackwardsCount(6,0.75);\r\n\r\n            ConveyorFunction(0.95);\r\n\r\n            ClawClose();\r\n\r\n            sleep(240);\r\n\r\n            shooter.setVelocity(2100);\r\n\r\n            Rotate(184, 0.75);\r\n\r\n            ForwardorBackwards(40,0.75);\r\n\r\n            ClawOpen();\r\n\r\n            sleep(100);\r\n\r\n            ForwardorBackwardsCount(-4,0.75);\r\n        }\r\n        if (count > 1) {\r\n\r\n            ForwardorBackwardsCount(24, 0.75); // move back to line to shoot\r\n\r\n            ConveyorFunction(1); //begin shooting\r\n\r\n            sleep(3500); //time to shoot\r\n\r\n            ForwardorBackwardsCount(40, 0.75);   //Going forwards to put Long arm down\r\n\r\n            Strafing(7, -1);     // A lining for Long arm\r\n\r\n            LongArmFunctionDown();  // Putting wobble goal arm down\r\n\r\n            sleep(230);\r\n\r\n            ClawOpen();    //Opening the claw after putting down number 1 wobble goal\r\n\r\n            sleep(230);\r\n\r\n            LongArmFunctionUP();\r\n\r\n            ForwardorBackwardsCount(-28,0.75);   //Going back to line\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FTC_14133_2021_Auto.java	(revision 7c690a28eb8c989f917d1a68bf12b372708e122c)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FTC_14133_2021_Auto.java	(date 1619046427889)
@@ -283,7 +283,7 @@
         ForwardorBackwardsCount(-14,0.5); //move quickly to ring stack
 
         ForwardorBackwardsCount(-16, 0.5);    // move slowly to pick up rings, count code in drive while loop
-
+        }
 
 
 
@@ -408,5 +408,4 @@
 
             ForwardorBackwardsCount(-28,0.75);   //Going back to line
         }
-    }
-}
\ No newline at end of file
+    }
\ No newline at end of file
